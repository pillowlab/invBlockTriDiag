% test_unittest
%
% Compare non-symmetric and symmetric versions of code

N = 2; % size of blocks
T = 4; % number of blocks
TOL = 1e-10;  % tolerance for numerical error

% Build non-symmetric block-tridiagonal matrix
% --------------------------------------------

% Make diagonal blocks
BdiagMats = mat2cell(randn(N,N*T),N,N*ones(1,T)); % diagonal blocks
Bmat = blkdiag(BdiagMats{:});
% Make below-diagonal and above-diagonal blocks
Bdiag1Mats = mat2cell(randn(N,N*(T-1)),N,N*ones(1,T-1)); % diagonal blocks
Bdiag2Mats = mat2cell(randn(N,N*(T-1)),N,N*ones(1,T-1)); % diagonal blocks
Bdiag1 = blkdiag(Bdiag1Mats{:});
Bdiag2 = blkdiag(Bdiag2Mats{:});

% Assemble block-tridiagonal matrix
Bmat(N+1:end,1:end-N) = Bmat(N+1:end,1:end-N) + Bdiag1; % below-diagonal block
Bmat(1:end-N,N+1:end) = Bmat(1:end-N,N+1:end) + Bdiag2; % below-diagonal block
%Bmat = Bmat+Bmat';

%%  compute explicit inverse
Binv = inv(Bmat);

% Use our function
[vdiag1,B1,B2] = invblktridiag(Bmat,N);

%% Test for agreement
vdiag0 = diag(Binv); % diagonal element
diagdiff = sum(abs(vdiag1-vdiag0));
if diagdiff>TOL
    warning('unit test failed: diagonals don''t match');
else
    fprintf('invblktridiag unit test passed: diagonals match\n');
end

% Check diagonal blocks
MatchFAIL = 0;
for j_ind = 1:T
    ii = (j_ind-1)*N+1:j_ind*N;  % row/column indices
    aa = Binv(ii,ii);   % block from direct inverse 
    bb = B1(:,:,j_ind); % computed block
    errs = (abs((aa(:)-bb(:))));
    if any(errs>TOL)
        MatchFAIL = 1
    end
end
if MatchFAIL
    warning('invblktridiag unit test failed: diagonal blocks don''t match');
else
    fprintf('invblktridiag unit test passed: diagonal blocks match\n');
end
% Check below-diagonal blocks
MatchFAIL = 0;
for j_ind = 1:T-1
    ii = (j_ind-1)*N+1:j_ind*N; % rows
    jj = j_ind*N+1:(j_ind+1)*N; % columns
    aa = Binv(ii,jj);  % block from direct inverse 
    bb = B2(:,:,j_ind);
    errs = (abs((aa(:)-bb(:))));
    if any(errs>TOL)
        MatchFAIL = 1
    end
end
if MatchFAIL
    warning('invblktridiag unit test failed: below-diagonal blocks don''t match');
else
    fprintf('invblktridiag unit test passed: below-diagonal blocks match\n');
end
    


% 
% % verify that diagonals are the same
% [vdiag0 vdiag1]
% 
% 
% % Now reconstruct main blocks of inverse from B1 and B2
% MinvBlck = zeros(T*2,T*2);
% MinvBlck(1:2,1:2) = B1(:,:,1);
% for jj=2:T
%     inds = 2*(jj-1)+1:2*jj;
%     MinvBlck(inds,inds) = B1(:,:,jj);
%     MinvBlck(inds,inds-2) = B2(:,:,jj-1); % below diagonal
%     MinvBlck(inds-2,inds) = B2(:,:,jj-1)'; % above diagonal
% end
% 
% subplot(131);
% imagesc(Minv); axis image;  title('full inverse');
% 
% subplot(132);
% imagesc(MinvBlck); axis image;  title('three main blocks of inverse');
% 
% subplot(133);
% plot(1:2*T, spdiags(Minv,[-2,-1,1,2]), 'b', 1:2*T, spdiags(MinvBlck,[-2,-1,1,2]), 'r--', 'linewidth', 2);
% title('comparison of off-diagonal terms');
